// tslint:disable
/**
 * Copyright 2019 Splunk, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"): you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * Data Stream Processing REST API
 * With the Splunk Cloud Data Stream Processing service, you can perform create, read, update, and delete (CRUD) operations on your data pipeline. The Streams API also has metrics and preview session endpoints and gives you full control over your data pipeline
 *
 * OpenAPI spec version: v2beta1.2 (recommended default)
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import BaseApiService from '../../../baseapiservice';
import {
    ActivatePipelineRequest,
    ConnectionPatchRequest,
    ConnectionPutRequest,
    ConnectionRequest,
    ConnectionSaveResponse,
    DeactivatePipelineRequest,
    DslCompilationRequest,
    GetInputSchemaRequest,
    GetOutputSchemaRequest,
    GroupExpandRequest,
    GroupPatchRequest,
    GroupPutRequest,
    GroupRequest,
    GroupResponse,
    MetricsResponse,
    PaginatedResponseOfConnectionResponse,
    PaginatedResponseOfConnectorResponse,
    PaginatedResponseOfPipelineJobStatus,
    PaginatedResponseOfPipelineResponse,
    PaginatedResponseOfTemplateResponse,
    PipelineDeleteResponse,
    PipelinePatchRequest,
    PipelineReactivateResponse,
    PipelineRequest,
    PipelineResponse,
    PipelinesMergeRequest,
    PreviewData,
    PreviewSessionStartRequest,
    PreviewStartResponse,
    PreviewState,
    Response,
    SplCompileRequest,
    TemplatePatchRequest,
    TemplatePutRequest,
    TemplateRequest,
    TemplateResponse,
    UplPipeline,
    UplRegistry,
    UplType,
    ValidateRequest,
    ValidateResponse,
} from '../../../models/streams';
import { SplunkError } from '../../../client';

export const STREAMS_SERVICE_PREFIX: string = '/streams/v2beta1';
export const STREAMS_SERVICE_CLUSTER: string = 'api';

/**
 * Data Stream Processing REST API
 * Version: v2beta1.2
 * With the Splunk Cloud Data Stream Processing service, you can perform create, read, update, and delete (CRUD) operations on your data pipeline. The Streams API also has metrics and preview session endpoints and gives you full control over your data pipeline
 */
export abstract class StreamsServiceGen extends BaseApiService {
    /**
     * Activates an existing pipeline.
     * @param id id of the pipeline to activate
     * @param activatePipelineRequest Request JSON
     * @param queryParams Query parameters to be sent with the request
     * @return Response
     */
    public activatePipeline = (id: string, activatePipelineRequest: ActivatePipelineRequest, queryParams?: object): Promise<Response> => {
        const path_params = {
            id: id
        };
        const path = this.template`/streams/v2beta1/pipelines/${'id'}/activate`(path_params);
        return this.client.post(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), activatePipelineRequest, { query: queryParams })
            .then(response => response.body as Response);
    }
    /**
     * Compiles the Streams DSL and returns Streams JSON.
     * @param dslCompilationRequest Request JSON
     * @param queryParams Query parameters to be sent with the request
     * @return UplPipeline
     */
    public compileDSL = (dslCompilationRequest: DslCompilationRequest, queryParams?: object): Promise<UplPipeline> => {
        const path = `/streams/v2beta1/pipelines/compile-dsl`;
        return this.client.post(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), dslCompilationRequest, { query: queryParams })
            .then(response => response.body as UplPipeline);
    }
    /**
     * Compiles SPL2 and returns Streams JSON.
     * @param splCompileRequest Request JSON
     * @param queryParams Query parameters to be sent with the request
     * @return UplPipeline
     */
    public compileSPL = (splCompileRequest: SplCompileRequest, queryParams?: object): Promise<UplPipeline> => {
        const path = `/streams/v2beta1/pipelines/compile-spl`;
        return this.client.post(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), splCompileRequest, { query: queryParams })
            .then(response => response.body as UplPipeline);
    }
    /**
     * Create a new DSP connection.
     * @param connectionRequest Request JSON
     * @param queryParams Query parameters to be sent with the request
     * @return ConnectionSaveResponse
     */
    public createConnection = (connectionRequest: ConnectionRequest, queryParams?: object): Promise<ConnectionSaveResponse> => {
        const path = `/streams/v2beta1/connections`;
        return this.client.post(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), connectionRequest, { query: queryParams })
            .then(response => response.body as ConnectionSaveResponse);
    }
    /**
     * Create a new group function by combining the Streams JSON of two or more functions.
     * @param groupRequest Request JSON
     * @param queryParams Query parameters to be sent with the request
     * @return GroupResponse
     */
    public createGroup = (groupRequest: GroupRequest, queryParams?: object): Promise<GroupResponse> => {
        const path = `/streams/v2beta1/groups`;
        return this.client.post(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), groupRequest, { query: queryParams })
            .then(response => response.body as GroupResponse);
    }
    /**
     * Creates a pipeline.
     * @param pipelineRequest Request JSON
     * @param queryParams Query parameters to be sent with the request
     * @return PipelineResponse
     */
    public createPipeline = (pipelineRequest: PipelineRequest, queryParams?: object): Promise<PipelineResponse> => {
        const path = `/streams/v2beta1/pipelines`;
        return this.client.post(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), pipelineRequest, { query: queryParams })
            .then(response => response.body as PipelineResponse);
    }
    /**
     * Creates a template for a tenant.
     * @param templateRequest Request JSON
     * @param queryParams Query parameters to be sent with the request
     * @return TemplateResponse
     */
    public createTemplate = (templateRequest: TemplateRequest, queryParams?: object): Promise<TemplateResponse> => {
        const path = `/streams/v2beta1/templates`;
        return this.client.post(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), templateRequest, { query: queryParams })
            .then(response => response.body as TemplateResponse);
    }
    /**
     * Deactivates an existing pipeline.
     * @param id id of the pipeline to deactivate
     * @param deactivatePipelineRequest Request JSON
     * @param queryParams Query parameters to be sent with the request
     * @return Response
     */
    public deactivatePipeline = (id: string, deactivatePipelineRequest: DeactivatePipelineRequest, queryParams?: object): Promise<Response> => {
        const path_params = {
            id: id
        };
        const path = this.template`/streams/v2beta1/pipelines/${'id'}/deactivate`(path_params);
        return this.client.post(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), deactivatePipelineRequest, { query: queryParams })
            .then(response => response.body as Response);
    }
    /**
     * Delete all versions of a connection by its id.
     * @param connectionId ID of the connection
     * @param queryParams Query parameters to be sent with the request
     */
    public deleteConnection = (connectionId: string, queryParams?: object): Promise<object> => {
        const path_params = {
            connectionId: connectionId
        };
        const path = this.template`/streams/v2beta1/connections/${'connectionId'}`(path_params);
        return this.client.delete(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: queryParams })
            .then(response => response.body as object);
    }
    /**
     * Removes an existing group.
     * @param groupId The group function's ID from the function registry
     * @param queryParams Query parameters to be sent with the request
     */
    public deleteGroup = (groupId: string, queryParams?: object): Promise<object> => {
        const path_params = {
            groupId: groupId
        };
        const path = this.template`/streams/v2beta1/groups/${'groupId'}`(path_params);
        return this.client.delete(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: queryParams })
            .then(response => response.body as object);
    }
    /**
     * Removes a pipeline.
     * @param id id of the pipeline to delete
     * @param queryParams Query parameters to be sent with the request
     * @return PipelineDeleteResponse
     */
    public deletePipeline = (id: string, queryParams?: object): Promise<PipelineDeleteResponse> => {
        const path_params = {
            id: id
        };
        const path = this.template`/streams/v2beta1/pipelines/${'id'}`(path_params);
        return this.client.delete(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: queryParams })
            .then(response => response.body as PipelineDeleteResponse);
    }
    /**
     * Removes a template with a specific ID.
     * @param templateId ID of the template to delete
     * @param queryParams Query parameters to be sent with the request
     */
    public deleteTemplate = (templateId: string, queryParams?: object): Promise<object> => {
        const path_params = {
            templateId: templateId
        };
        const path = this.template`/streams/v2beta1/templates/${'templateId'}`(path_params);
        return this.client.delete(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: queryParams })
            .then(response => response.body as object);
    }
    /**
     * Creates and returns the expanded version of a group.
     * @param groupId The group function's ID from the function registry
     * @param groupExpandRequest Request JSON
     * @param queryParams Query parameters to be sent with the request
     * @return UplPipeline
     */
    public expandGroup = (groupId: string, groupExpandRequest: GroupExpandRequest, queryParams?: object): Promise<UplPipeline> => {
        const path_params = {
            groupId: groupId
        };
        const path = this.template`/streams/v2beta1/groups/${'groupId'}/expand`(path_params);
        return this.client.post(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), groupExpandRequest, { query: queryParams })
            .then(response => response.body as UplPipeline);
    }
    /**
     * Returns the entire Streams JSON, including the expanded Streams JSON of any group functions in the pipeline.
     * @param uplPipeline Request JSON
     * @param queryParams Query parameters to be sent with the request
     * @return UplPipeline
     */
    public expandPipeline = (uplPipeline: UplPipeline, queryParams?: object): Promise<UplPipeline> => {
        const path = `/streams/v2beta1/pipelines/expand`;
        return this.client.post(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), uplPipeline, { query: queryParams })
            .then(response => response.body as UplPipeline);
    }
    /**
     * Returns the full Streams JSON of a group.
     * @param groupId The group function's ID from the function registry
     * @param queryParams Query parameters to be sent with the request
     * @return GroupResponse
     */
    public getGroup = (groupId: string, queryParams?: object): Promise<GroupResponse> => {
        const path_params = {
            groupId: groupId
        };
        const path = this.template`/streams/v2beta1/groups/${'groupId'}`(path_params);
        return this.client.get(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: queryParams })
            .then(response => response.body as GroupResponse);
    }
    /**
     * Returns the input schema for a function in a pipeline.
     * @param getInputSchemaRequest Input Schema Request
     * @param queryParams Query parameters to be sent with the request
     * @return UplType
     */
    public getInputSchema = (getInputSchemaRequest: GetInputSchemaRequest, queryParams?: object): Promise<UplType> => {
        const path = `/streams/v2beta1/pipelines/input-schema`;
        return this.client.post(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), getInputSchemaRequest, { query: queryParams })
            .then(response => response.body as UplType);
    }
    /**
     * Returns the output schema for a specified function in a pipeline. If no function ID is  specified, the request returns the output schema for all functions in a pipeline.
     * @param getOutputSchemaRequest Output Schema Request
     * @param queryParams Query parameters to be sent with the request
     * @return { [key: string]: UplType; }
     */
    public getOutputSchema = (getOutputSchemaRequest: GetOutputSchemaRequest, queryParams?: object): Promise<{ [key: string]: UplType; }> => {
        const path = `/streams/v2beta1/pipelines/output-schema`;
        return this.client.post(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), getOutputSchemaRequest, { query: queryParams })
            .then(response => response.body as { [key: string]: UplType; });
    }
    /**
     * Returns an individual pipeline by version.
     * @param id id of the pipeline to get
     * @param queryParams Query parameters to be sent with the request
     * @param queryParams.version version
     * @return PipelineResponse
     */
    public getPipeline = (id: string, queryParams?: { version?: string, [key: string]: any }): Promise<PipelineResponse> => {
        const path_params = {
            id: id
        };
        const path = this.template`/streams/v2beta1/pipelines/${'id'}`(path_params);
        return this.client.get(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: queryParams })
            .then(response => response.body as PipelineResponse);
    }
    /**
     * Returns the latest metrics for a single pipeline.
     * @param id ID of the pipeline to get metrics for
     * @param queryParams Query parameters to be sent with the request
     * @return MetricsResponse
     */
    public getPipelineLatestMetrics = (id: string, queryParams?: object): Promise<MetricsResponse> => {
        const path_params = {
            id: id
        };
        const path = this.template`/streams/v2beta1/pipelines/${'id'}/metrics/latest`(path_params);
        return this.client.get(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: queryParams })
            .then(response => response.body as MetricsResponse);
    }
    /**
     * Returns the status of pipelines from the underlying streaming system.
     * @param queryParams Query parameters to be sent with the request
     * @param queryParams.activated activated
     * @param queryParams.createUserId createUserId
     * @param queryParams.name name
     * @param queryParams.offset offset
     * @param queryParams.pageSize pageSize
     * @param queryParams.sortDir sortDir
     * @param queryParams.sortField sortField
     * @return PaginatedResponseOfPipelineJobStatus
     */
    public getPipelinesStatus = (queryParams?: { activated?: boolean, createUserId?: string, name?: string, offset?: number, pageSize?: number, sortDir?: string, sortField?: string, [key: string]: any }): Promise<PaginatedResponseOfPipelineJobStatus> => {
        const path = `/streams/v2beta1/pipelines/status`;
        return this.client.get(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: queryParams })
            .then(response => response.body as PaginatedResponseOfPipelineJobStatus);
    }
    /**
     * Returns the preview data for a session.
     * @param previewSessionId ID of the preview session
     * @param queryParams Query parameters to be sent with the request
     * @return PreviewData
     */
    public getPreviewData = (previewSessionId: number, queryParams?: object): Promise<PreviewData> => {
        const path_params = {
            previewSessionId: previewSessionId.toString()
        };
        const path = this.template`/streams/v2beta1/preview-data/${'previewSessionId'}`(path_params);
        return this.client.get(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: queryParams })
            .then(response => response.body as PreviewData);
    }
    /**
     * Returns information from a preview session.
     * @param previewSessionId ID of the preview session
     * @param queryParams Query parameters to be sent with the request
     * @return PreviewState
     */
    public getPreviewSession = (previewSessionId: number, queryParams?: object): Promise<PreviewState> => {
        const path_params = {
            previewSessionId: previewSessionId.toString()
        };
        const path = this.template`/streams/v2beta1/preview-session/${'previewSessionId'}`(path_params);
        return this.client.get(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: queryParams })
            .then(response => response.body as PreviewState);
    }
    /**
     * Returns the latest metrics for a preview session.
     * @param previewSessionId ID of the preview session
     * @param queryParams Query parameters to be sent with the request
     * @return MetricsResponse
     */
    public getPreviewSessionLatestMetrics = (previewSessionId: number, queryParams?: object): Promise<MetricsResponse> => {
        const path_params = {
            previewSessionId: previewSessionId.toString()
        };
        const path = this.template`/streams/v2beta1/preview-session/${'previewSessionId'}/metrics/latest`(path_params);
        return this.client.get(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: queryParams })
            .then(response => response.body as MetricsResponse);
    }
    /**
     * Returns all functions in JSON format.
     * @param queryParams Query parameters to be sent with the request
     * @param queryParams.local local
     * @return UplRegistry
     */
    public getRegistry = (queryParams?: { local?: boolean, [key: string]: any }): Promise<UplRegistry> => {
        const path = `/streams/v2beta1/pipelines/registry`;
        return this.client.get(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: queryParams })
            .then(response => response.body as UplRegistry);
    }
    /**
     * Returns an individual template by version.
     * @param templateId ID of the template
     * @param queryParams Query parameters to be sent with the request
     * @param queryParams.version version of the template
     * @return TemplateResponse
     */
    public getTemplate = (templateId: string, queryParams?: { version?: number, [key: string]: any }): Promise<TemplateResponse> => {
        const path_params = {
            templateId: templateId
        };
        const path = this.template`/streams/v2beta1/templates/${'templateId'}`(path_params);
        return this.client.get(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: queryParams })
            .then(response => response.body as TemplateResponse);
    }
    /**
     * Returns a list of connections (latest versions only) by tenant ID.
     * @param queryParams Query parameters to be sent with the request
     * @param queryParams.connectorId
     * @param queryParams.createUserId
     * @param queryParams.functionId
     * @param queryParams.name
     * @param queryParams.offset
     * @param queryParams.pageSize
     * @param queryParams.showSecretNames
     * @param queryParams.sortDir Specify either ascending ('asc') or descending ('desc') sort order for a given field (sortField), which must be set for sortDir to apply. Defaults to 'asc'.
     * @param queryParams.sortField
     * @return PaginatedResponseOfConnectionResponse
     */
    public listConnections = (queryParams?: { connectorId?: string, createUserId?: string, functionId?: string, name?: string, offset?: number, pageSize?: number, showSecretNames?: string, sortDir?: string, sortField?: string, [key: string]: any }): Promise<PaginatedResponseOfConnectionResponse> => {
        const path = `/streams/v2beta1/connections`;
        return this.client.get(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: queryParams })
            .then(response => response.body as PaginatedResponseOfConnectionResponse);
    }
    /**
     * Returns a list of the available connectors.
     * @param queryParams Query parameters to be sent with the request
     * @return PaginatedResponseOfConnectorResponse
     */
    public listConnectors = (queryParams?: object): Promise<PaginatedResponseOfConnectorResponse> => {
        const path = `/streams/v2beta1/connectors`;
        return this.client.get(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: queryParams })
            .then(response => response.body as PaginatedResponseOfConnectorResponse);
    }
    /**
     * Returns all pipelines.
     * @param queryParams Query parameters to be sent with the request
     * @param queryParams.activated activated
     * @param queryParams.createUserId createUserId
     * @param queryParams.includeData includeData
     * @param queryParams.name name
     * @param queryParams.offset offset
     * @param queryParams.pageSize pageSize
     * @param queryParams.sortDir sortDir
     * @param queryParams.sortField sortField
     * @return PaginatedResponseOfPipelineResponse
     */
    public listPipelines = (queryParams?: { activated?: boolean, createUserId?: string, includeData?: boolean, name?: string, offset?: number, pageSize?: number, sortDir?: string, sortField?: string, [key: string]: any }): Promise<PaginatedResponseOfPipelineResponse> => {
        const path = `/streams/v2beta1/pipelines`;
        return this.client.get(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: queryParams })
            .then(response => response.body as PaginatedResponseOfPipelineResponse);
    }
    /**
     * Returns a list of all templates.
     * @param queryParams Query parameters to be sent with the request
     * @param queryParams.offset offset
     * @param queryParams.pageSize pageSize
     * @param queryParams.sortDir sortDir
     * @param queryParams.sortField sortField
     * @return PaginatedResponseOfTemplateResponse
     */
    public listTemplates = (queryParams?: { offset?: number, pageSize?: number, sortDir?: string, sortField?: string, [key: string]: any }): Promise<PaginatedResponseOfTemplateResponse> => {
        const path = `/streams/v2beta1/templates`;
        return this.client.get(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: queryParams })
            .then(response => response.body as PaginatedResponseOfTemplateResponse);
    }
    /**
     * Combines two Streams JSON programs.
     * @param pipelinesMergeRequest Request JSON
     * @param queryParams Query parameters to be sent with the request
     * @return UplPipeline
     */
    public mergePipelines = (pipelinesMergeRequest: PipelinesMergeRequest, queryParams?: object): Promise<UplPipeline> => {
        const path = `/streams/v2beta1/pipelines/merge`;
        return this.client.post(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), pipelinesMergeRequest, { query: queryParams })
            .then(response => response.body as UplPipeline);
    }
    /**
     * Modifies an existing DSP connection.
     * @param connectionId ID of the connection
     * @param connectionPutRequest Request JSON
     * @param queryParams Query parameters to be sent with the request
     * @return ConnectionSaveResponse
     */
    public putConnection = (connectionId: string, connectionPutRequest: ConnectionPutRequest, queryParams?: object): Promise<ConnectionSaveResponse> => {
        const path_params = {
            connectionId: connectionId
        };
        const path = this.template`/streams/v2beta1/connections/${'connectionId'}`(path_params);
        return this.client.put(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), connectionPutRequest, { query: queryParams })
            .then(response => response.body as ConnectionSaveResponse);
    }
    /**
     * Update a group function combining the Streams JSON of two or more functions.
     * @param groupId The group function's ID from the function registry
     * @param groupPutRequest Request JSON
     * @param queryParams Query parameters to be sent with the request
     * @return GroupResponse
     */
    public putGroup = (groupId: string, groupPutRequest: GroupPutRequest, queryParams?: object): Promise<GroupResponse> => {
        const path_params = {
            groupId: groupId
        };
        const path = this.template`/streams/v2beta1/groups/${'groupId'}`(path_params);
        return this.client.put(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), groupPutRequest, { query: queryParams })
            .then(response => response.body as GroupResponse);
    }
    /**
     * Updates an existing template.
     * @param templateId ID of the template
     * @param templatePutRequest Request JSON
     * @param queryParams Query parameters to be sent with the request
     * @return TemplateResponse
     */
    public putTemplate = (templateId: string, templatePutRequest: TemplatePutRequest, queryParams?: object): Promise<TemplateResponse> => {
        const path_params = {
            templateId: templateId
        };
        const path = this.template`/streams/v2beta1/templates/${'templateId'}`(path_params);
        return this.client.put(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), templatePutRequest, { query: queryParams })
            .then(response => response.body as TemplateResponse);
    }
    /**
     * Reactivate a pipeline
     * @param id Pipeline UUID to reactivate
     * @param queryParams Query parameters to be sent with the request
     * @return PipelineReactivateResponse
     */
    public reactivatePipeline = (id: string, queryParams?: object): Promise<PipelineReactivateResponse> => {
        const path_params = {
            id: id
        };
        const path = this.template`/streams/v2beta1/pipelines/${'id'}/reactivate`(path_params);
        return this.client.post(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: queryParams })
            .then(response => response.body as PipelineReactivateResponse);
    }
    /**
     * Creates a preview session for a pipeline.
     * @param previewSessionStartRequest Parameters to start a new Preview session
     * @param queryParams Query parameters to be sent with the request
     * @return PreviewStartResponse
     */
    public startPreview = (previewSessionStartRequest: PreviewSessionStartRequest, queryParams?: object): Promise<PreviewStartResponse> => {
        const path = `/streams/v2beta1/preview-session`;
        return this.client.post(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), previewSessionStartRequest, { query: queryParams })
            .then(response => response.body as PreviewStartResponse);
    }
    /**
     * Stops a preview session.
     * @param previewSessionId ID of the preview session
     * @param queryParams Query parameters to be sent with the request
     * @return string
     */
    public stopPreview = (previewSessionId: number, queryParams?: object): Promise<string> => {
        const path_params = {
            previewSessionId: previewSessionId.toString()
        };
        const path = this.template`/streams/v2beta1/preview-session/${'previewSessionId'}`(path_params);
        return this.client.delete(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: queryParams })
            .then(response => response.body as string);
    }
    /**
     * Partially modifies an existing DSP connection.
     * @param connectionId ID of the connection
     * @param connectionPatchRequest Request JSON
     * @param queryParams Query parameters to be sent with the request
     * @return ConnectionSaveResponse
     */
    public updateConnection = (connectionId: string, connectionPatchRequest: ConnectionPatchRequest, queryParams?: object): Promise<ConnectionSaveResponse> => {
        const path_params = {
            connectionId: connectionId
        };
        const path = this.template`/streams/v2beta1/connections/${'connectionId'}`(path_params);
        return this.client.patch(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), connectionPatchRequest, { query: queryParams })
            .then(response => response.body as ConnectionSaveResponse);
    }
    /**
     * Modify a group function by combining the Streams JSON of two or more functions.
     * @param groupId The group function's ID from the function registry
     * @param groupPatchRequest Request JSON
     * @param queryParams Query parameters to be sent with the request
     * @return GroupResponse
     */
    public updateGroup = (groupId: string, groupPatchRequest: GroupPatchRequest, queryParams?: object): Promise<GroupResponse> => {
        const path_params = {
            groupId: groupId
        };
        const path = this.template`/streams/v2beta1/groups/${'groupId'}`(path_params);
        return this.client.patch(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), groupPatchRequest, { query: queryParams })
            .then(response => response.body as GroupResponse);
    }
    /**
     * Partially modifies an existing pipeline.
     * @param id id of the pipeline to update
     * @param pipelinePatchRequest Request JSON
     * @param queryParams Query parameters to be sent with the request
     * @return PipelineResponse
     */
    public updatePipeline = (id: string, pipelinePatchRequest: PipelinePatchRequest, queryParams?: object): Promise<PipelineResponse> => {
        const path_params = {
            id: id
        };
        const path = this.template`/streams/v2beta1/pipelines/${'id'}`(path_params);
        return this.client.patch(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), pipelinePatchRequest, { query: queryParams })
            .then(response => response.body as PipelineResponse);
    }
    /**
     * Partially modifies an existing template.
     * @param templateId ID of the template
     * @param templatePatchRequest Request JSON
     * @param queryParams Query parameters to be sent with the request
     * @return TemplateResponse
     */
    public updateTemplate = (templateId: string, templatePatchRequest: TemplatePatchRequest, queryParams?: object): Promise<TemplateResponse> => {
        const path_params = {
            templateId: templateId
        };
        const path = this.template`/streams/v2beta1/templates/${'templateId'}`(path_params);
        return this.client.patch(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), templatePatchRequest, { query: queryParams })
            .then(response => response.body as TemplateResponse);
    }
    /**
     * Verifies whether the Streams JSON is valid.
     * @param validateRequest JSON UPL to validate
     * @param queryParams Query parameters to be sent with the request
     * @return ValidateResponse
     */
    public validatePipeline = (validateRequest: ValidateRequest, queryParams?: object): Promise<ValidateResponse> => {
        const path = `/streams/v2beta1/pipelines/validate`;
        return this.client.post(STREAMS_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), validateRequest, { query: queryParams })
            .then(response => response.body as ValidateResponse);
    }
}
