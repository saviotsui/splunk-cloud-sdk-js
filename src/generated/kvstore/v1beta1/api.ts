// tslint:disable
/**
 * Copyright 2019 Splunk, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"): you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * KV Store API
 * With the Splunk Cloud KV store service, you can save and retrieve data within your Splunk apps, enabling you to manage and maintain the state of the application.
 *
 * OpenAPI spec version: v1beta1.1
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import BaseApiService from '../../../baseapiservice';
import {
    ErrorResponse,
    IndexDefinition,
    IndexDescription,
    Key,
    PingResponse,
} from '../../../models/kvstore';
import { SplunkError } from '../../../client';

export const KVSTORE_SERVICE_PREFIX: string = '/kvstore/v1beta1';
export const KVSTORE_SERVICE_CLUSTER: string = 'api';

/**
 * KV Store API
 * Version: v1beta1.1
 * With the Splunk Cloud KV store service, you can save and retrieve data within your Splunk apps, enabling you to manage and maintain the state of the application.
 */
export abstract class KvstoreServiceGen extends BaseApiService {
    /**
     * Creates an index on a collection.
     * @param collection The name of the collection.
     * @param indexDefinition
     * @return IndexDescription
     */
    public createIndex = (collection: string, indexDefinition?: IndexDefinition): Promise<IndexDescription> => {
        if (!indexDefinition) {
            throw new SplunkError({ message: `Bad Request: indexDefinition is empty or undefined` });
        }
        const path_params = {
            collection: collection
        };
        const path = this.template`/kvstore/v1beta1/collections/${'collection'}/indexes`(path_params);
        return this.client.post(KVSTORE_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), indexDefinition)
            .then(response => response.body as IndexDescription);
    }
    /**
     * Removes an index from a collection.
     * @param collection The name of the collection.
     * @param index The name of the index.
     */
    public deleteIndex = (collection: string, index: string): Promise<object> => {
        const path_params = {
            collection: collection,
            index: index
        };
        const path = this.template`/kvstore/v1beta1/collections/${'collection'}/indexes/${'index'}`(path_params);
        return this.client.delete(KVSTORE_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)))
            .then(response => response.body as object);
    }
    /**
     * Deletes a record with a given key.
     * @param collection The name of the collection.
     * @param key The key of the record.
     */
    public deleteRecordByKey = (collection: string, key: string): Promise<object> => {
        const path_params = {
            collection: collection,
            key: key
        };
        const path = this.template`/kvstore/v1beta1/collections/${'collection'}/records/${'key'}`(path_params);
        return this.client.delete(KVSTORE_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)))
            .then(response => response.body as object);
    }
    /**
     * Removes records in a collection that match the query.
     * @param collection The name of the collection.
     * @param args All other arguments.
     * @param args.query Query JSON expression.
     */
    public deleteRecords = (collection: string, args?: { query?: string }): Promise<object> => {
        const path_params = {
            collection: collection
        };
        const path = this.template`/kvstore/v1beta1/collections/${'collection'}/query`(path_params);
        return this.client.delete(KVSTORE_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: args })
            .then(response => response.body as object);
    }
    /**
     * Returns a record with a given key.
     * @param collection The name of the collection.
     * @param key The key of the record.
     * @return { [key: string]: any; }
     */
    public getRecordByKey = (collection: string, key: string): Promise<{ [key: string]: any; }> => {
        const path_params = {
            collection: collection,
            key: key
        };
        const path = this.template`/kvstore/v1beta1/collections/${'collection'}/records/${'key'}`(path_params);
        return this.client.get(KVSTORE_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)))
            .then(response => response.body as { [key: string]: any; });
    }
    /**
     * Inserts a record into a collection.
     * @param collection The name of the collection.
     * @param body Record to add to the collection, formatted as a JSON object.
     * @return Key
     */
    public insertRecord = (collection: string, body: { [key: string]: any; }): Promise<Key> => {
        const path_params = {
            collection: collection
        };
        const path = this.template`/kvstore/v1beta1/collections/${'collection'}`(path_params);
        return this.client.post(KVSTORE_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), body)
            .then(response => response.body as Key);
    }
    /**
     * Inserts multiple records in a single request.
     * @param collection The name of the collection.
     * @param requestBody Array of records to insert.
     * @return Array<string>
     */
    public insertRecords = (collection: string, requestBody: Array<{ [key: string]: any; }>): Promise<Array<string>> => {
        const path_params = {
            collection: collection
        };
        const path = this.template`/kvstore/v1beta1/collections/${'collection'}/batch`(path_params);
        return this.client.post(KVSTORE_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), requestBody)
            .then(response => response.body as Array<string>);
    }
    /**
     * Returns a list of all indexes on a collection.
     * @param collection The name of the collection.
     * @return Array<IndexDefinition>
     */
    public listIndexes = (collection: string): Promise<Array<IndexDefinition>> => {
        const path_params = {
            collection: collection
        };
        const path = this.template`/kvstore/v1beta1/collections/${'collection'}/indexes`(path_params);
        return this.client.get(KVSTORE_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)))
            .then(response => response.body as Array<IndexDefinition>);
    }
    /**
     * Use key-value query parameters to filter fields. Fields are implicitly ANDed and values for the same field are implicitly ORed.
     * Returns a list of records in a collection with basic filtering, sorting, pagination and field projection.
     * @param collection The name of the collection.
     * @param args All other arguments.
     * @param args.count Maximum number of records to return.
     * @param args.fields Comma-separated list of fields to include or exclude.
     * @param args.filters
     * @param args.offset Number of records to skip from the start.
     * @param args.orderby Sort order. Format is `<field>:<sort order>`. Valid sort orders are 1 for ascending, -1 for descending.
     * @return Array<{ [key: string]: any; }>
     */
    public listRecords = (collection: string, args?: { count?: number, fields?: Array<string>, filters?: { [key: string]: any; }, offset?: number, orderby?: Array<string> }): Promise<Array<{ [key: string]: any; }>> => {
        const path_params = {
            collection: collection
        };
        const path = this.template`/kvstore/v1beta1/collections/${'collection'}`(path_params);
        return this.client.get(KVSTORE_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: args })
            .then(response => response.body as Array<{ [key: string]: any; }>);
    }
    /**
     * Returns the health status from the database.
     * @return PingResponse
     */
    public ping = (): Promise<PingResponse> => {
        const path = `/kvstore/v1beta1/ping`;
        return this.client.get(KVSTORE_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)))
            .then(response => response.body as PingResponse);
    }
    /**
     * Updates the record with a given key, either by inserting or replacing the record.
     * @param collection The name of the collection.
     * @param key The key of the record.
     * @param body Record to add to the collection, formatted as a JSON object.
     * @return Key
     */
    public putRecord = (collection: string, key: string, body: { [key: string]: any; }): Promise<Key> => {
        const path_params = {
            collection: collection,
            key: key
        };
        const path = this.template`/kvstore/v1beta1/collections/${'collection'}/records/${'key'}`(path_params);
        return this.client.put(KVSTORE_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), body)
            .then(response => response.body as Key);
    }
    /**
     * Returns a list of query records in a collection.
     * @param collection The name of the collection.
     * @param args All other arguments.
     * @param args.count Maximum number of records to return.
     * @param args.fields Comma-separated list of fields to include or exclude.
     * @param args.offset Number of records to skip from the start.
     * @param args.orderby Sort order. Format is `<field>:<sort order>`. Valid sort orders are 1 for ascending, -1 for descending.
     * @param args.query Query JSON expression.
     * @return Array<{ [key: string]: any; }>
     */
    public queryRecords = (collection: string, args?: { count?: number, fields?: Array<string>, offset?: number, orderby?: Array<string>, query?: string }): Promise<Array<{ [key: string]: any; }>> => {
        const path_params = {
            collection: collection
        };
        const path = this.template`/kvstore/v1beta1/collections/${'collection'}/query`(path_params);
        return this.client.get(KVSTORE_SERVICE_CLUSTER, this.client.buildPath('', path.split('/').slice(1)), { query: args })
            .then(response => response.body as Array<{ [key: string]: any; }>);
    }
}
